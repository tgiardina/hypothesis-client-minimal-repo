{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/boot/boot.js",
    "src/boot/browser-check.js",
    "src/boot/index.js",
    "src/boot/parse-json-config.js",
    "src/boot/polyfills/index.js",
    "src/boot/url-template.js"
  ],
  "names": [
    "outer",
    "modules",
    "cache",
    "entry",
    "previousRequire",
    "hypothesisRequire",
    "newRequire",
    "name",
    "jumped",
    "currentRequire",
    "err",
    "Error",
    "code",
    "m",
    "exports",
    "call",
    "x",
    "id",
    "i",
    "length",
    "1",
    "require",
    "module",
    "t",
    "e",
    "querySelector",
    "injectLink",
    "sidebarAppUrl",
    "notebookAppUrl",
    "assetRoot",
    "r",
    "polyfillBundles",
    "commonPolyfills",
    "injectAssets",
    "concat",
    "_toConsumableArray",
    "_polyfills",
    "Array",
    "isArray",
    "_arrayLikeToArray",
    "_arrayWithoutHoles",
    "Symbol",
    "iterator",
    "Object",
    "from",
    "_iterableToArray",
    "prototype",
    "toString",
    "slice",
    "constructor",
    "test",
    "_unsupportedIterableToArray",
    "TypeError",
    "_nonIterableSpread",
    "n",
    "tagElement",
    "setAttribute",
    "o",
    "createElement",
    "rel",
    "href",
    "type",
    "head",
    "appendChild",
    "forEach",
    "manifest",
    "match",
    "injectStylesheet",
    "src",
    "async",
    "injectScript",
    "requiredPolyfillSets",
    "map",
    "defineProperty",
    "value",
    "isBrowserSupported",
    "Promise",
    "resolve",
    "Map",
    "URL",
    "document",
    "location",
    "Request",
    "Element",
    "prepend",
    "evaluate",
    "XPathResult",
    "ANY_TYPE",
    "_parseJsonConfig",
    "_boot",
    "_urlTemplate",
    "__esModule",
    "default",
    "settings",
    "parseJsonConfig",
    "__MANIFEST__",
    "bootSidebarApp",
    "bootHypothesisClient",
    "console",
    "warn",
    "assign",
    "s",
    "hasOwnProperty",
    "querySelectorAll",
    "JSON",
    "parse",
    "textContent",
    "hasMethods",
    "arguments",
    "every",
    "filter",
    "needsPolyfill",
    "es2017",
    "es2018",
    "extractOrigin",
    "protocol",
    "hostname",
    "currentScriptOrigin",
    "currentScript",
    "indexOf",
    "replace"
  ],
  "mappings": "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",
  "sourcesContent": [
    "\n// modules are defined as an array\n// [ module function, map of requireuires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the requireuire for previous bundles\n\n(function() {\n\nfunction outer(modules, cache, entry) {\n    // Save the require from previous bundle to this closure if any\n    var previousRequire = typeof hypothesisRequire == \"function\" && hypothesisRequire;;\n\n    function newRequire(name, jumped){\n        if(!cache[name]) {\n            if(!modules[name]) {\n                // if we cannot find the module within our internal map or\n                // cache jump to the current global require ie. the last bundle\n                // that was added to the page.\n                var currentRequire = typeof hypothesisRequire == \"function\" && hypothesisRequire;;\n                if (!jumped && currentRequire) return currentRequire(name, true);\n\n                // If there are other bundles on this page the require from the\n                // previous one is saved to 'previousRequire'. Repeat this as\n                // many times as there are bundles until the module is found or\n                // we exhaust the require chain.\n                if (previousRequire) return previousRequire(name, true);\n                var err = new Error('Cannot find module \\'' + name + '\\'');\n                err.code = 'MODULE_NOT_FOUND';\n                throw err;\n            }\n            var m = cache[name] = {exports:{}};\n            modules[name][0].call(m.exports, function(x){\n                var id = modules[name][1][x];\n                return newRequire(id ? id : x);\n            },m,m.exports,outer,modules,cache,entry);\n        }\n        return cache[name].exports;\n    }\n    for(var i=0;i<entry.length;i++) newRequire(entry[i]);\n\n    // Override the current require with this new one\n    return newRequire;\n}\n\nreturn outer;\n\n})()\n",
    "import { requiredPolyfillSets } from './polyfills';\n\n/**\n * Polyfills used by both the annotator and sidebar app.\n */\nconst commonPolyfills = [\n  // ES APIs\n  'es2017',\n  'es2018',\n\n  // Any other polyfills which may rely on certain ES APIs should be listed here.\n];\n\n/**\n * @typedef SidebarAppConfig\n * @prop {string} assetRoot - The root URL to which URLs in `manifest` are relative\n * @prop {Object.<string,string>} manifest -\n *   A mapping from canonical asset path to cache-busted asset path\n */\n\n/**\n * @typedef AnnotatorConfig\n * @prop {string} assetRoot - The root URL to which URLs in `manifest` are relative\n * @prop {string} notebookAppUrl - The URL of the sidebar's notebook\n * @prop {string} sidebarAppUrl - The URL of the sidebar's HTML page\n * @prop {Object.<string,string>} manifest -\n *   A mapping from canonical asset path to cache-busted asset path\n */\n\n/**\n * Mark an element as having been added by the boot script.\n *\n * This marker is later used to know which elements to remove when unloading\n * the client.\n *\n * @param {HTMLElement} el\n */\nfunction tagElement(el) {\n  el.setAttribute('data-hypothesis-asset', '');\n}\n\n/**\n * @param {Document} doc\n * @param {string} href\n */\nfunction injectStylesheet(doc, href) {\n  const link = doc.createElement('link');\n  link.rel = 'stylesheet';\n  link.type = 'text/css';\n  link.href = href;\n\n  tagElement(link);\n  doc.head.appendChild(link);\n}\n\n/**\n * @param {Document} doc\n * @param {string} src - The script URL\n */\nfunction injectScript(doc, src) {\n  const script = doc.createElement('script');\n  script.type = 'text/javascript';\n  script.src = src;\n\n  // Set 'async' to false to maintain execution order of scripts.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n  script.async = false;\n\n  tagElement(script);\n  doc.head.appendChild(script);\n}\n\n/**\n * @param {Document} doc\n * @param {string} rel\n * @param {'html'|'javascript'} type\n * @param {string} url\n */\nfunction injectLink(doc, rel, type, url) {\n  const link = doc.createElement('link');\n  link.rel = rel;\n  link.href = url;\n  link.type = `application/annotator+${type}`;\n\n  tagElement(link);\n  doc.head.appendChild(link);\n}\n\n/**\n * @param {Document} doc\n * @param {SidebarAppConfig|AnnotatorConfig} config\n * @param {string[]} assets\n */\nfunction injectAssets(doc, config, assets) {\n  assets.forEach(function (path) {\n    const url = config.assetRoot + 'build/' + config.manifest[path];\n    if (url.match(/\\.css/)) {\n      injectStylesheet(doc, url);\n    } else {\n      injectScript(doc, url);\n    }\n  });\n}\n\nfunction polyfillBundles(needed) {\n  return requiredPolyfillSets(needed).map(\n    set => `scripts/polyfills-${set}.bundle.js`\n  );\n}\n\n/**\n * Bootstrap the Hypothesis client.\n *\n * This triggers loading of the necessary resources for the client\n *\n * @param {Document} doc\n * @param {AnnotatorConfig} config\n */\nexport function bootHypothesisClient(doc, config) {\n  // Detect presence of Hypothesis in the page\n  const appLinkEl = doc.querySelector(\n    'link[type=\"application/annotator+html\"]'\n  );\n  if (appLinkEl) {\n    return;\n  }\n\n  // Register the URL of the sidebar app which the Hypothesis client should load.\n  // The <link> tag is also used by browser extensions etc. to detect the\n  // presence of the Hypothesis client on the page.\n  injectLink(doc, 'sidebar', 'html', config.sidebarAppUrl);\n\n  // Register the URL of the notebook app which the Hypothesis client should load.\n  injectLink(doc, 'notebook', 'html', config.notebookAppUrl);\n\n  // Register the URL of the annotation client which is currently being used to drive\n  // annotation interactions.\n  injectLink(\n    doc,\n    'hypothesis-client',\n    'javascript',\n    config.assetRoot + 'build/boot.js'\n  );\n\n  const polyfills = polyfillBundles(commonPolyfills);\n\n  injectAssets(doc, config, [\n    // Vendor code and polyfills\n    ...polyfills,\n\n    // Main entry point for the client\n    'scripts/annotator.bundle.js',\n\n    'styles/annotator.css',\n    'styles/pdfjs-overrides.css',\n  ]);\n}\n\n/**\n * Bootstrap the sidebar application which displays annotations.\n *\n * @param {Document} doc\n * @param {SidebarAppConfig} config\n */\nexport function bootSidebarApp(doc, config) {\n  const polyfills = polyfillBundles(commonPolyfills);\n\n  injectAssets(doc, config, [\n    ...polyfills,\n\n    // Vendor code required by sidebar.bundle.js\n    'scripts/sentry.bundle.js',\n    'scripts/katex.bundle.js',\n    'scripts/showdown.bundle.js',\n\n    // The sidebar app\n    'scripts/sidebar.bundle.js',\n\n    'styles/katex.min.css',\n    'styles/sidebar.css',\n  ]);\n}\n",
    "/**\n * Run a series of representative feature tests to see if the browser is new\n * enough to support Hypothesis.\n *\n * We use feature tests to try to avoid false negatives, accepting some risk of\n * false positives due to the host page having loaded polyfills for APIs in order\n * to support older browsers.\n *\n * @return {boolean}\n */\nexport function isBrowserSupported() {\n  const checks = [\n    // ES APIs.\n    () => Promise.resolve(),\n    () => new Map(),\n\n    // DOM API checks for frequently-used APIs.\n    () => new URL(document.location.href), // URL constructor.\n    () => new Request('https://hypothes.is'), // Part of the `fetch` API.\n    () => Element.prototype.prepend.name,\n\n    // DOM API checks for less frequently-used APIs.\n    // These are less likely to have been polyfilled by the host page.\n    () => {\n      document.evaluate(\n        '/html/body',\n        document,\n\n        // These arguments are optional in the spec but required in Edge Legacy.\n        null /* namespaceResolver */,\n        XPathResult.ANY_TYPE,\n        null /* result */\n      );\n    },\n  ];\n\n  try {\n    checks.forEach(check => check());\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n",
    "// This is the main entry point for the Hypothesis client in the host page\n// and the sidebar application.\n//\n// The same boot script is used for both entry points so that the browser\n// already has it cached when it encounters the reference in the sidebar\n// application.\n\n// Variables replaced by the build script\n\n/* global __MANIFEST__ */\n\nimport { parseJsonConfig } from './parse-json-config';\n\nimport { bootHypothesisClient, bootSidebarApp } from './boot';\nimport processUrlTemplate from './url-template';\nimport { isBrowserSupported } from './browser-check';\n\nif (isBrowserSupported()) {\n  const settings = parseJsonConfig(document);\n  const assetRoot = processUrlTemplate(settings.assetRoot || '__ASSET_ROOT__');\n  // @ts-ignore - `__MANIFEST__` is injected by the build script\n  const manifest = __MANIFEST__;\n\n  // Check whether this is the sidebar app (indicated by the presence of a\n  // `<hypothesis-app>` element) and load the appropriate part of the client.\n  if (document.querySelector('hypothesis-app')) {\n    bootSidebarApp(document, { assetRoot, manifest });\n  } else {\n    const notebookAppUrl = processUrlTemplate(\n      settings.notebookAppUrl || '__NOTEBOOK_APP_URL__'\n    );\n    const sidebarAppUrl = processUrlTemplate(\n      settings.sidebarAppUrl || '__SIDEBAR_APP_URL__'\n    );\n    bootHypothesisClient(document, {\n      assetRoot,\n      manifest,\n      notebookAppUrl,\n      sidebarAppUrl,\n    });\n  }\n} else {\n  // Show a \"quiet\" warning to avoid being disruptive on non-Hypothesis sites\n  // that embed the client.\n  //\n  // In Via or when using the bookmarklet we could show something louder.\n  console.warn(\n    'The Hypothesis annotation tool is not supported in this browser. See https://web.hypothes.is/help/which-browsers-are-supported-by-hypothesis/.'\n  );\n}\n",
    "// `Object.assign()`-like helper. Used because this script needs to work\n// in IE 10/11 without polyfills.\nfunction assign(dest, src) {\n  for (const k in src) {\n    if (src.hasOwnProperty(k)) {\n      dest[k] = src[k];\n    }\n  }\n  return dest;\n}\n\n/**\n * Return a parsed `js-hypothesis-config` object from the document, or `{}`.\n *\n * Find all `<script class=\"js-hypothesis-config\">` tags in the given document,\n * parse them as JSON, and return the parsed object.\n *\n * If there are no `js-hypothesis-config` tags in the document then return\n * `{}`.\n *\n * If there are multiple `js-hypothesis-config` tags in the document then merge\n * them into a single returned object (when multiple scripts contain the same\n * setting names, scripts further down in the document override those further\n * up).\n *\n * @param {Document|Element} document - The root element to search.\n */\nexport function parseJsonConfig(document) {\n  const config = {};\n  const settingsElements = document.querySelectorAll(\n    'script.js-hypothesis-config'\n  );\n\n  for (let i = 0; i < settingsElements.length; i++) {\n    let settings;\n    try {\n      settings = JSON.parse(settingsElements[i].textContent || '');\n    } catch (err) {\n      console.warn(\n        'Could not parse settings from js-hypothesis-config tags',\n        err\n      );\n      settings = {};\n    }\n    assign(config, settings);\n  }\n\n  return config;\n}\n",
    "/**\n * Checkers to test which polyfills are required by the current browser.\n *\n * This module executes in an environment without any polyfills loaded so it\n * needs to run in old browsers, down to IE 11.\n *\n * See gulpfile.js for details of how to add a new polyfill.\n */\n\n/**\n * Return true if `obj` has all of the methods in `methods`.\n */\nfunction hasMethods(obj, ...methods) {\n  return methods.every(method => typeof obj[method] === 'function');\n}\n\n/**\n * Map of polyfill set name to function to test whether the current browser\n * needs that polyfill set.\n *\n * Each checker function returns `true` if the polyfill is required or `false`\n * if the browser has the functionality natively available.\n */\nconst needsPolyfill = {\n  es2017: () => {\n    return !hasMethods(Object, 'entries', 'values');\n  },\n\n  es2018: () => {\n    return (\n      typeof Promise !== 'function' || !hasMethods(Promise.prototype, 'finally')\n    );\n  },\n};\n\n/**\n * Return the subset of polyfill sets from `needed`  which are needed by the\n * current browser.\n */\nexport function requiredPolyfillSets(needed) {\n  return needed.filter(set => {\n    const checker = needsPolyfill[set];\n    if (!checker) {\n      throw new Error(`Unknown polyfill set \"${set}\"`);\n    }\n    return checker();\n  });\n}\n",
    "/**\n * Extract the protocol and hostname (ie. host without port) from the URL.\n *\n * We don't use the URL constructor here because IE and early versions of Edge\n * do not support it and this code runs early in the life of the app before any\n * polyfills can be loaded.\n */\nfunction extractOrigin(url) {\n  const match = url.match(/(https?):\\/\\/([^:/]+)/);\n  if (!match) {\n    return null;\n  }\n  return { protocol: match[1], hostname: match[2] };\n}\n\nfunction currentScriptOrigin(document_ = document) {\n  const scriptEl = /** @type {HTMLScriptElement|null} */ (document_.currentScript);\n  if (!scriptEl) {\n    // Function was called outside of initial script execution.\n    return null;\n  }\n  return extractOrigin(scriptEl.src);\n}\n\n/**\n * Replace references to `current_host` and `current_scheme` URL template\n * parameters with the corresponding elements of the current script URL.\n *\n * During local development, there are cases when the client/h needs to be accessed\n * from a device or VM that is not the system where the development server is\n * running. In that case, all references to `localhost` need to be replaced\n * with the IP/hostname of the dev server.\n *\n * @param {string} url\n * @param {Document} document_\n */\nexport default function processUrlTemplate(url, document_ = document) {\n  if (url.indexOf('{') === -1) {\n    // Not a template. This should always be the case in production.\n    return url;\n  }\n\n  const origin = currentScriptOrigin(document_);\n\n  if (origin) {\n    url = url.replace('{current_host}', origin.hostname);\n    url = url.replace('{current_scheme}', origin.protocol);\n  } else {\n    throw new Error(\n      'Could not process URL template because script origin is unknown'\n    );\n  }\n\n  return url;\n}\n"
  ],
  "sourceRoot": ""
}